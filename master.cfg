# -*- python -*-
# ex: set filetype=python:


"""
master.cfg

DO NOT EDIT THIS FILE LOCALLY!
ITS UNDER VERSION CONTROL AND UPDATES FROM GIT.

See here:
    git@github.com:andreasofthings/buildbot.git

"""

import json
import requests
import datetime
from buildbot.plugins import *

from buildbot.www.oauth2 import OAuth2Auth  # for custom authentication
from buildbot.secrets.providers.base import SecretProviderBase  # for custom secrets


class PramariAuth(OAuth2Auth):
    """This is a customer authentication class subclassed from 'py:buildbot.www.oauth2.OAuth2Auth', that 
    helps users authenticate against the awesome ''
    
    :param name: Name of the Authenticator, defaults to 'Pramari'
    :type name: str
    """
    name = "Pramari"
    faIcon = "fa-python"
    resourceEndpoint = "https://www.pramari.de"
    authUri = "https://pramari.de/o/authorize/"
    tokenUri = "https://pramari.de/o/token/"
    authUriAdditionalParams = dict(
        scope=" ".join(
            [
                "userinfo",
            ]
        )
    )

    def getUserInfoFromOAuthClient(self, c):
        data = self.get(c, "/api/userinfo/")
        return dict(
            full_name="{}, {}".format(data["last_name"], data["first_name"]),
            username=data["username"],
            email=data["email"],
            # avatar_url=data["picture"]
        )

    def createSessionFromToken(self, token):
        s = requests.Session()
        s.headers = {"Authorization": "bearer " + token["access_token"]}
        s.verify = self.sslVerify
        return s


class GoogleCloudSecretProvider(SecretProviderBase):
    """Basic provider where each secret is stored in Vault KV secret engine.
    
    Todo:
      * read secrets from google
      * make it actually work with buildbot
    """

    name = "GoogleCloudSecret"
    _secret = {}

    def __init__(self, *args, **kwargs):
        from google.cloud import secretmanager

        secrets = secretmanager.SecretManagerServiceClient()
        response = secrets.access_secret_version(
            request={"name": kwargs["secretname"]})
        self._secret = json.loads(response.payload.data.decode("UTF-8"))
        super().__init__(*args, **kwargs)

    def get(self, entry):
        return self._secret.get(entry, None)


class LimitAppEngineVersions(steps.BuildStep):
    from twisted.internet import defer

    def __init__(self, serviceName=None, limit=15, **kwargs):

        if not serviceName:
            raise TypeError("servicename argument is required")

        # call parent
        super().__init__(**kwargs)

    # @defer.inlineCallbacks
    def run(self):
        from googleapiclient.discovery import build
        with build('appengine', 'v1') as service:
            pass


class ReleaseDate(steps.BuildStep):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def run(self, **kwargs):
        try:
            with open('release', 'w') as f:
                """
                .. todo::
                  actually update date in `release`
                """
                n = datetime.datetime.now()
                f.write(f'{n.year}-{n.month}-{n.day}-{n.hour}')
        except IOError:
            print("File not accessible")


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### SECRETS

c["secretsProviders"] = [
    secrets.SecretInAFile(dirname="/home/andreas_neumeier_org/.ssh/"),
    GoogleCloudSecretProvider(
        secretname="projects/pramari-de/secrets/dbdetail/versions/latest"
    ),
]


####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

kube_config = util.KubeCtlProxyConfigLoader()

c["workers"] = [
    # worker.Worker("localworker", "pass", properties={"os":"Debian Buster"}, keepalive_interval=300),
    worker.LocalWorker("bot1"),
    worker.KubeLatentWorker("kubeworker", namespace="default", kube_config=kube_config),
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c["protocols"] = {"pb": {"port": 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot version of a python hello-world project.

c["change_source"] = []
# c['change_source'].append(changes.github.GitHubPullrequestPoller('git://github.com/andreasofthings/apc.git', pollInterval=599))
# c['change_source'].append(changes.GitPoller(
#       'git://github.com/buildbot/hello-world.git',
#        workdir='gitpoller-workdir', branch='master',
#        pollInterval=300))

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

c["schedulers"] = []
daily_documentation_scheduler = schedulers.Periodic(
    name="hourly", builderNames=["Build Documentation"], periodicBuildTimer=60 * 60 * 12
)
daily_staticfile_scheduler = schedulers.Periodic(
    name="daily", builderNames=["Collect Staticfiles"], periodicBuildTimer=24 * 60 * 60
)

quality_scheduler = schedulers.SingleBranchScheduler(
    name="Quality Check Scheduler",
    change_filter=util.ChangeFilter(branch="main"),
    treeStableTimer=30,
    builderNames=[
        "Check Quality",
    ],
)
tests_scheduler = schedulers.Dependent(
    name="Run Tests Scheduler",
    upstream=quality_scheduler,
    builderNames=[
        "Run Tests",
    ],
)
deploy_scheduler = schedulers.Dependent(
    name="deploy",
    upstream=tests_scheduler,  # <- no quotes!
    builderNames=[
        "Deploy AppEngine",
    ],
)
crmeta_scheduler = schedulers.SingleBranchScheduler(
    name="prepare & build crmeta package",
    change_filter=util.ChangeFilter(branch="main"),
    builderNames=["crmeta package"]
)
build_all_scheduler = schedulers.SingleBranchScheduler(
    name="Build All Scheduler",
    change_filter=util.ChangeFilter(branch="main"),
    treeStableTimer=None,
    builderNames=[
        "Check Quality",
        "Run Tests",
        "Deploy AppEngine",
    ],
)

force_scheduler = schedulers.ForceScheduler(
    name="force",
    builderNames=[
        "Deploy AppEngine",
        "Run Tests",
        "Check Quality",
        "Build Documentation",
        "Collect Staticfiles",
        "Deploy Website",  # neumeier.org is not automated
        "Deploy Webapp",  # app.pramari.de is not automated
        "crmeta package",
    ],
)

c["schedulers"].append(daily_documentation_scheduler)
c["schedulers"].append(daily_staticfile_scheduler)
c["schedulers"].append(quality_scheduler)
c["schedulers"].append(tests_scheduler)
c["schedulers"].append(deploy_scheduler)
c['schedulers'].append(build_all_scheduler)
c["schedulers"].append(crmeta_scheduler)
c["schedulers"].append(force_scheduler)

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

### Fetch Source Steps

fetchapc = steps.Git(
    name="Fetch Source for APC",
    repourl="git@github.com:andreasofthings/apc.git", mode="incremental"
)
fetchweb = steps.Git(
    name="Fetch Source for neumeier.org",
    repourl="git@github.com:andreasofthings/neumeier.org.git", mode="incremental"
)
fetchwebapp = steps.Git(
    name="fetch source for pramari webapp. (using deploykey)",
    repourl="git@github.com:andreasofthings/pramari-app.git",
    mode="incremental",
    sshPrivateKey=util.Secret("id_rsa_webapp"),
    sshKnownHosts=util.Secret("known_hosts"),
)
fetchcrmeta = steps.Git(
        name="fetch crmeta package source",
        repourl="git@github.com:andreasofthings/crmeta.git",
        mode="incremental"
    )

### Venv Steps

create_venv = steps.ShellCommand(
    name="Create a Virtual Environment",
    command=["python3", "-m", "venv", "env"]
    )
update_pip = steps.ShellCommand(
    name="Update pip in Virtual Environment",
    command=["./env/bin/python3", "-m", "pip", "install",
             "--upgrade", "pip", "pylint", "pyflakes", "mypy"]
)
prep_venv = steps.ShellCommand(
    name="Install requirements.txt",
    command=[
        "./env/bin/python3",
        "-m",
        "pip",
        "install",
        "--upgrade",
        "-r",
        "requirements.txt",
    ]
)


### BuildFactories

quality_factory = util.BuildFactory()
quality_factory.addStep(fetchapc)
quality_factory.addStep(create_venv)
quality_factory.addStep(update_pip)
quality_factory.addStep(prep_venv)
quality_factory.addStep(
    steps.PyFlakes(command=["./env/bin/python3", "-m", "pyflakes", "webapp"])
)
quality_factory.addStep(
    steps.PyLint(command=["./env/bin/python3", "-m", "pylint", "webapp"])
)
quality_factory.addStep(
    steps.PyLint(command=["./env/bin/python3", "-m", "mypy", "--install-types",
                 "--non-interactive", "--ignore-missing-imports", "webapp"])
)

test_factory = util.BuildFactory()
test_factory.addStep(fetchapc)
test_factory.addStep(create_venv)
test_factory.addStep(update_pip)
test_factory.addStep(prep_venv)
test_factory.addStep(
    steps.ShellCommand(
        name="Run all tests through `manage.py test`",
        command=["./env/bin/python3", "manage.py", "test"],
        env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json", "BUILDBOT": "True"},
    )
)

"""
    Set CLOUDSDK_CONFIG to some temp directory
    gcloud auth activate-service-account --key-file=...
    ... use gcloud to do your work ...
    Remove temp CLOUDSDK_CONFIG directory.
"""

deploy_factory = util.BuildFactory()
deploy_factory.addStep(fetchapc)
deploy_factory.addStep(
    steps.ShellCommand(
        command=[
            "gcloud",
            "auth",
            "activate-service-account",
            "--key-file=pramari.json",
        ],
        env={"GCLOUDSDK_CONFIG": "tmp"},
    )
)

# deploy_factory.addStep(
#    ReleaseDate(
#        name="Update Release Date"
#    )
# )

#deploy_factory.addStep(
#    LimitAppEngineVersions(serviceName="default")
#)

deploy_factory.addStep(
    steps.ShellCommand(
        name="Deploy to AppEngine",
        command=["gcloud", "app", "deploy"], env={"GCLOUDSDK_CONFIG": "tmp"}
    )
)

doc_factory = util.BuildFactory()
doc_factory.addStep(fetchapc)
doc_factory.addStep(create_venv)
doc_factory.addStep(update_pip)
doc_factory.addStep(prep_venv)
doc_factory.addStep(
  steps.ShellCommand(
    name="Build Documentation",
    command=[
        "./env/bin/sphinx-build",
        "docs/source",
        "docs/build"
    ]
  )
)
doc_factory.addStep(
    steps.ShellCommand(
        name="Copy Documentation to gs://",
        command=["gsutil", "-m", "cp", "-r",
                 "docs/build/*", "gs://docs.pramari.de/"]
    )
)

static_factory = util.BuildFactory()
static_factory.addStep(fetchapc)
static_factory.addStep(create_venv)
static_factory.addStep(update_pip)
static_factory.addStep(prep_venv)
static_factory.addStep(
    steps.ShellCommand(
        name="Collect static files",
        command=["./env/bin/python3", "manage.py",
                 "collectstatic", "--noinput"],
        env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json"},
    )
)

web_factory = util.BuildFactory()
web_factory.addStep(fetchweb)
web_factory.addStep(
    steps.ShellCommand(
        command=[
            "hugo",
        ]
    )
)

webapp_factory = util.BuildFactory()
webapp_factory.addStep(fetchwebapp)
webapp_factory.addStep(
    steps.ShellCommand(
        command=[
            "gcloud",
            "auth",
            "activate-service-account",
            "--key-file=pramari.json",
        ],
        env={"GCLOUDSDK_CONFIG": "tmp"},
    )
)
webapp_factory.addStep(
    steps.ShellCommand(
        command=["gcloud", "app", "deploy"], env={"GCLOUDSDK_CONFIG": "tmp"}
    )
)

crmeta_factory = util.BuildFactory()
crmeta_factory.addStep(fetchcrmeta)
crmeta_factory.addStep(create_venv)
crmeta_factory.addStep(update_pip)
crmeta_factory.addStep(prep_venv)
crmeta_factory.addStep(
    steps.PyFlakes(command=["./env/bin/python3", "-m", "pyflakes", "crmeta"])
)
crmeta_factory.addStep(
    steps.PyLint(command=["./env/bin/python3", "-m", "pylint", "crmeta"])
)
crmeta_factory.addStep(
    steps.ShellCommand(command=["behave", "crmeta/features"])
)
crmeta_factory.addStep(
    steps.ShellCommand(command=["./env/bin/python3", "runtests.py"])
)

### Builders Configuration

c["builders"] = []
c["builders"].append(
    util.BuilderConfig(
        name="Deploy AppEngine", workernames=["bot1", ], factory=deploy_factory
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Run Tests", workernames=["bot1", ], factory=test_factory
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Check Quality", workernames=["kubeworker", ], factory=quality_factory
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Build Documentation", workernames=["bot1", ], factory=doc_factory
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Collect Staticfiles", workernames=["bot1", ], factory=static_factory
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Deploy Website", workernames=["bot1", ], factory=web_factory
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Deploy Webapp", workernames=["bot1", ], factory=webapp_factory
    )
)

c["builders"].append(
    util.BuilderConfig(
        name="crmeta package", workernames=["bot1", ], factory=crmeta_factory
    )
)

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

context = util.Interpolate("bb/%(prop:buildername)s")
c["services"] = []
c["services"].append(
    reporters.GitHubStatusPush(
        token="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", context=context
    )
)
c["buildbotNetUsageData"] = "full"

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c["title"] = "pramari.de ci/cd"
c["titleURL"] = "https://www.pramari.de"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c["buildbotURL"] = "https://build.pramari.de/"

authz = util.Authz(
    allowRules=[
        util.AnyControlEndpointMatcher(role="admins", defaultDeny=True),
        util.AnyEndpointMatcher(role="admins", defaultDeny=True),
    ],
    roleMatchers=[util.RolesFromEmails(admins=["andreas@neumeier.org"])],
)

c["www"] = dict(
    port=8010,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={},
        badges={"left_pad": 0, "right_pad": 0,
                "border_radius": 3, "style": "badgeio"},
    ),
    # auth=util.GoogleAuth("82960315302-tbj0fvm03aviuah0ps66991qhjrtopak.apps.googleusercontent.com", "eVsvW5FkUKU65JJj8ksz26fX"),
    auth=PramariAuth(
        clientId="ThF4JwVtvyG46W1NhGc5FYRCRFbte0btLkEJ8pvS",
        clientSecret="PwyIc5LYV7Cb76hoPNG51RQ2N7y81PhHtvBudzQEiRGCbBktwZDJk4XbGrV6HTdvHWzinfrOIOy4orr5Ch2DcWPriNVbcWAK0HQrDPXdD2YysNWpwNngRSucWbxRbcte",
    ),
    change_hook_dialects={
        "github": {
            "secret": "BRbNFGkfC$os9W)3mXCYer>vf2,j;w2MYfzNRRdMz{HGVa6zbaoPi6fb6Fs?EEpw"
        }
    },
    authz=authz,
)

####### DB URL

c["db"] = {
    # This specifies what database buildbot uses to store its state.
    # It's easy to start with sqlite, but it's recommended to switch to a dedicated
    # database, such as PostgreSQL or MySQL, for use in production environments.
    # http://docs.buildbot.net/current/manual/configuration/global.html#database-specification
    "db_url": "sqlite:///state.sqlite",
}
# sec = secrets.SecretInAFile(dirname="/home/andreas_neumeier_org/.ssh/")
print("Secret: %s", util.Secret("KEYS"))
