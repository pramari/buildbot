# -*- python -*-
# ex: set filetype=python:


"""
master.cfg

DO NOT EDIT THIS FILE LOCALLY!
ITS UNDER VERSION CONTROL AND UPDATES FROM GIT.

See here:
    git@github.com:pramari/buildbot.git

"""

import os
import json
import requests
import datetime
from buildbot.plugins import util, steps, secrets, worker, schedulers, reporters


from buildbot.www.oauth2 import OAuth2Auth  # for custom authentication
from buildbot.secrets.providers.base import SecretProviderBase  # for custom secrets
from twisted.internet import defer


project_id = "pramari-de"

from google.cloud import secretmanager
cloudsecrets = secretmanager.SecretManagerServiceClient()
name = f"projects/{project_id}/secrets/dbdetail/versions/latest"
response = cloudsecrets.access_secret_version(name=name)
SECRET = json.loads(response.payload.data.decode("UTF-8")).get("BUILDBOT", None)



class PramariAuth(OAuth2Auth):
    """This is a customer authentication class subclassed from 'py:buildbot.www.oauth2.OAuth2Auth', that
    helps users authenticate against the awesome ''

    :param name: Name of the Authenticator, defaults to 'Pramari'
    :type name: str
    """

    name = "Pramari"
    faIcon = "fa-python"
    resourceEndpoint = "https://www.pramari.de"
    authUri = "https://pramari.de/o/authorize/"
    tokenUri = "https://pramari.de/o/token/"
    authUriAdditionalParams = dict(
        scope=" ".join(
            [
                # "openid",
                "userinfo",
            ]
        )
    )

    def getUserInfoFromOAuthClient(self, c):
        data = self.get(c, "/api/userinfo/")
        return dict(
            full_name="{}, {}".format(data["last_name"], data["first_name"]),
            username=data["username"],
            email=data["email"],
            # avatar_url=data["picture"]
        )

    def createSessionFromToken(self, token):
        s = requests.Session()
        s.headers = {"Authorization": "bearer " + token["access_token"]}
        s.verify = self.sslVerify
        return s


class GoogleCloudSecretProvider(SecretProviderBase):
    """Basic provider where each secret is stored in Vault KV secret engine.

    Todo:
      * read secrets from google
      * make it actually work with buildbot

    Reference:
        https://github.com/buildbot/buildbot/blob/3bc2181a6ee38381a72272f31923ee599d61c7e0/master/buildbot/secrets/providers/vault.py
    """

    name = "GoogleCloudSecret"
    _secret = {}

    def __init__(self, *args, **kwargs):
        """
        kwargs:: secretname
        kwargs:: secretversion
        """
        from google.cloud import secretmanager

        secrets = secretmanager.SecretManagerServiceClient()
        response = secrets.access_secret_version(request={"name": kwargs["secretname"]})
        self._secret = json.loads(response.payload.data.decode("UTF-8"))
        super().__init__(*args, **kwargs)

    @defer.inlineCallbacks
    def get(self, key):
        """
        return the value from the secret in 
        Google Cloud Platform Secret Manager
        """
        try:
            return self._secret[key]
        except KeyError as e:
            raise KeyError(
                f"The secret {entry} does not exist in Vault provider: {e}") from e
        secret = self._secret.get(entry, None)
        return 


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### SECRETS

c["secretsProviders"] = [
    secrets.SecretInAFile(dirname="/home/andreas_neumeier_org/.ssh/", strip=False),
    #GoogleCloudSecretProvider(
    #   secretname="projects/pramari-de/secrets/ssh/versions/latest"
    #),
]


####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

kube_config = util.KubeCtlProxyConfigLoader()

c["workers"] = [
    # worker.Worker("localworker", "pass", properties={"os":"Debian Buster"}, keepalive_interval=300),
    worker.LocalWorker("bot1"),
    worker.KubeLatentWorker(
        "kubeworker",
        namespace="default",
        kube_config=kube_config,
        masterFQDN="10.156.15.212",
        image='ghcr.io/pramari/buildbot-worker:main',
        keepalive_interval=60,
    ),
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c["protocols"] = {"pb": {"port": 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  

c["change_source"] = []
# c['change_source'].append(changes.github.GitHubPullrequestPoller('git://github.com/andreasofthings/apc.git', pollInterval=599))
# c['change_source'].append(changes.GitPoller(
#       'git://github.com/buildbot/hello-world.git',
#        workdir='gitpoller-workdir', branch='master',
#        pollInterval=300))


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

### Fetch Source Steps

fetchapc_ssh = steps.GitHub(
    name="Fetch Source for APC (with key)",
    repourl="git@github.com:andreasofthings/apc.git",
    branch="main",
    mode="full",
    method="clobber",
    sshPrivateKey=util.Secret("id_rsa"),
    sshHostKey=util.Secret("github.com"),
)

fetchnpc_ssh = steps.GitHub(
    name="Fetch Source for APC (with key)",
    repourl="git@github.com:pramari/npc.git",
    branch="main",
    mode="full",
    method="clobber",
    sshPrivateKey=util.Secret("id_rsa"),
    sshHostKey=util.Secret("github.com"),
)


fetchcrmeta = steps.GitHub(
    name="Fetch crmeta Package Source",
    repourl="git@github.com:andreasofthings/crmeta.git",
    branch="main",
    mode="full",
    method="clobber",
    sshPrivateKey=util.Secret("id_rsa"),
    sshHostKey=util.Secret("github.com"),
)

### Generic venv Steps for all packages

create_venv = steps.ShellCommand(
    name="Create a Virtual Environment", 
    command=["python3", "-m", "virtualenv", "env"]
)

update_pip = steps.ShellCommand(
    name="Update pip in Virtual Environment",
    command=[
        "./env/bin/python3",
        "-m",
        "pip",
        "install",
        "--upgrade",
        "pip",
    ],
)
provide_testtools = steps.ShellCommand(
    name="Install PyLint, pyflakes and mypy",
    command=[
        "./env/bin/python3",
        "-m",
        "pip",
        "install",
        "--upgrade",
        "pylint",
        "pyflakes",
        "mypy",
    ],
)

install_requirements = prep_venv = steps.ShellCommand(
    name="Install requirements.txt",
    command=[
        "./env/bin/python3",
        "-m",
        "pip",
        "install",
        "--upgrade",
        "-r",
        "requirements.txt",
    ],
)

auth_gcloud = steps.ShellCommand(
        command=[
            "gcloud",
            "auth",
            "activate-service-account",
            "--key-file=pramari.json",
        ],
        env={"GCLOUDSDK_CONFIG": "tmp"},
    )


### BuildFactories

apc_quality_factory = util.BuildFactory()
apc_quality_factory.addStep(fetchapc_ssh)
apc_quality_factory.addStep(create_venv)
apc_quality_factory.addStep(update_pip)
apc_quality_factory.addStep(install_requirements)
apc_quality_factory.addStep(provide_testtools)
apc_quality_factory.addStep(
    steps.PyFlakes(command=["./env/bin/python3", "-m", "pyflakes", "webapp"])
)
apc_quality_factory.addStep(
    steps.PyLint(command=["./env/bin/python3", "-m", "pylint", "webapp"])
)
apc_quality_factory.addStep(
    steps.ShellCommand(
        name="MyPy",
        command=[
            "./env/bin/python3",
            "-m",
            "mypy",
            "--install-types",
            "--non-interactive",
            "--ignore-missing-imports",
            "webapp",
        ]
    )
)

apc_test_factory = util.BuildFactory()
apc_test_factory.addStep(fetchapc_ssh)
apc_test_factory.addStep(create_venv)
apc_test_factory.addStep(update_pip)
apc_test_factory.addStep(prep_venv)
apc_test_factory.addStep(
    steps.ShellCommand(
        name="Run all tests through `manage.py test`",
        command=["./env/bin/python3", "manage.py", "test"],
        env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json", "BUILDBOT": "True"},
    )
)


##### deploy
npc_cleanup_step = steps.ShellCommand(
    name="Limit AppEngine Service Version Count", 
    command=["gcloud", "app", "versions", "list", "--format=\"value(version.id)\"", "--sort-by=\"~version.createTime\"", "|", "tail", "-n", "+6", "|", "xargs", "-r", "gcloud", "app", "versions", "delete", "--quiet"]
)

npc_cleanup_factory = util.BuildFactory()
npc_cleanup_factory.addStep(auth_gcloud)
npc_cleanup_factory.addStep(npc_cleanup_step)


apc_deploy_factory = util.BuildFactory()
apc_deploy_factory.addStep(fetchnpc_ssh)
apc_deploy_factory.addStep(auth_gcloud)
apc_deploy_factory.addStep(npc_cleanup_step)

apc_deploy_factory.addStep(
    steps.ShellCommand(
        name="Deploy to AppEngine",
        command=["gcloud", "app", "deploy"],
        env={"GCLOUDSDK_CONFIG": "tmp"},
    )
)

apc_doc_factory = util.BuildFactory()
apc_doc_factory.addStep(fetchapc_ssh)
apc_doc_factory.addStep(create_venv)
apc_doc_factory.addStep(install_requirements)
apc_doc_factory.addStep(
    steps.ShellCommand(
        name="Install requirements.txt",
        command=[
            "./env/bin/python3",
            "-m",
            "pip",
            "install",
            "--upgrade",
            "sphinx",
        ],
    )                       
)

apc_doc_factory.addStep(
    steps.ShellCommand(
        name="Build Documentation",
        command=["./env/bin/sphinx-build", "docs/source", "docs/build"],
    )
)
apc_doc_factory.addStep(auth_gcloud)
apc_doc_factory.addStep(
    steps.ShellCommand(
        name="Copy Documentation to gs://",
        command=["gsutil", "-m", "cp", "-r", "docs/build/*", "gs://docs.pramari.de/"],
    )
)

apc_static_factory = util.BuildFactory()
apc_static_factory.addStep(fetchapc_ssh)
apc_static_factory.addStep(create_venv)
apc_static_factory.addStep(install_requirements)
apc_static_factory.addStep(auth_gcloud)
apc_static_factory.addStep(
    steps.ShellCommand(
        name="Collect static files",
        command=["./env/bin/python3", "manage.py", "collectstatic", "--noinput"],
        env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json"},
    )
)


### Builders Configuration

c["builders"] = []
c["builders"].append(
    util.BuilderConfig(
        name="Deploy APC to AppEngine",
        workernames=[
            "bot1",
        ],
        factory=apc_deploy_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Clean App Enginge Service Versions",
        workernames=["bot1",],
        factory=npc_cleanup_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Run APC Tests",
        workernames=[
            "kubeworker",
        ],
        factory=apc_test_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Check APC Quality",
        workernames=[
            "kubeworker",
        ],
        factory=apc_quality_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Build Documentation",
        workernames=[
            "kubeworker",
        ],
        factory=apc_doc_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Collect Staticfiles",
        workernames=[
            "kubeworker",
        ],
        factory=apc_static_factory,
    )
)

### Full Pipeline for CRMeta


#### CRMeta BuildFactory

crmeta_quality_factory = util.BuildFactory()
crmeta_quality_factory.addStep(fetchcrmeta)
crmeta_quality_factory.addStep(create_venv)
crmeta_quality_factory.addStep(update_pip)
crmeta_quality_factory.addStep(provide_testtools)
crmeta_quality_factory.addStep(
    steps.PyFlakes(command=["./env/bin/python3", "-m", "pyflakes", "crmeta"])
)
crmeta_quality_factory.addStep(
    steps.PyLint(command=["./env/bin/python3", "-m", "pylint", "crmeta"])
)
crmeta_quality_factory.addStep(
    steps.ShellCommand(command=["./env/bin/python3", "runtests.py"])
)

crmeta_behave_factory = util.BuildFactory()
crmeta_behave_factory.addStep(fetchcrmeta)
crmeta_behave_factory.addStep(create_venv)
crmeta_behave_factory.addStep(update_pip)
crmeta_behave_factory.addStep(provide_testtools)
crmeta_behave_factory.addStep(steps.ShellCommand(command=["behave", "crmeta/features"]))

crmeta_tox_factory = util.BuildFactory()
crmeta_tox_factory.addStep(fetchcrmeta)
crmeta_tox_factory.addStep(create_venv)
crmeta_tox_factory.addStep(update_pip)
crmeta_tox_factory.addStep(provide_testtools)
crmeta_tox_factory.addStep(steps.ShellCommand(command=["tox"]))


#### CRMeta Builders

c["builders"].append(
    util.BuilderConfig(
        name="crmeta quality",
        workernames=[
            "kubeworker",
        ],
        factory=crmeta_quality_factory,
    )
)

c["builders"].append(
    util.BuilderConfig(
        name="crmeta behave",
        workernames=[
            "kubeworker",
        ],
        factory=crmeta_behave_factory,
    )
)

c["builders"].append(
    util.BuilderConfig(
        name="crmeta tox",
        workernames=[
            "kubeworker",
        ],
        factory=crmeta_tox_factory,
    )
)

#### SCHEDULERS

###### CRMeta Scheduler

crmeta_quality_scheduler = schedulers.SingleBranchScheduler(
    name="On Code Change Quality Gate CRMeta Package",
    change_filter=util.ChangeFilter(
        repository="https://github.com/andreasofthings/crmeta",
        branch="main",
    ),
    builderNames=["crmeta quality"],
)

crmeta_tox_scheduler = schedulers.Dependent(
    name="Tox CRMeta Package",
    upstream=crmeta_quality_scheduler,
    builderNames=["crmeta tox"],
)

crmeta_behave_scheduler = schedulers.Dependent(
    name="Behave CRMeta Package",
    upstream=crmeta_tox_scheduler,
    builderNames=["crmeta behave"],
)

crmeta_schedulers = [
    crmeta_quality_scheduler,
    crmeta_tox_scheduler,
    crmeta_behave_scheduler,
]

###### APC SCHEDULERS

apc_quality_scheduler = schedulers.SingleBranchScheduler(
    name="Quality Check Scheduler",
    change_filter=util.ChangeFilter(
      repository="https://github.com/pramari/apc",
      branch="main"
      ),
    treeStableTimer=30,
    builderNames=[
        "Check APC Quality",
    ],
)
apc_tests_scheduler = schedulers.Dependent(
    name="Run Tests Scheduler",
    upstream=apc_quality_scheduler,
    builderNames=[
        "Run APC Tests",
    ],
)
apc_deploy_scheduler = schedulers.Dependent(
    name="deploy",
    upstream=apc_tests_scheduler,  # <- no quotes!
    builderNames=[
        "Deploy APC to AppEngine",
    ],
)

apc_schedulers = [
    apc_quality_scheduler,
    apc_tests_scheduler,
    apc_deploy_scheduler
]

###### Periodic

periodic_schedulers = [
    schedulers.Periodic(
        name="weekly", 
        builderNames=["Build Documentation", "Collect Staticfiles"], 
        periodicBuildTimer = 7 * 24 * 60 * 60  # Seconds 
    )
]

###### Force Scheduler 
force_scheduler = schedulers.ForceScheduler(
        name="force",
        builderNames=[
            "Build Documentation",      # every 24h only, otherwise
            "Collect Staticfiles",      # every 24h only, otherwise
            "Deploy APC to AppEngine",
            "Run APC Tests",
            "Check APC Quality",
            "crmeta quality",
            "crmeta tox",
            "crmeta behave",
            "Clean App Enginge Service Versions",
        ],
    )

###### Scheduler Summary

c["schedulers"] = []
c["schedulers"] += apc_schedulers
c["schedulers"] += crmeta_schedulers
# c["schedulers"] += periodic_schedulers
c["schedulers"].append(force_scheduler)                 # Force



####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.


c["services"] = []

c["services"].append(
    reporters.GitHubStatusPush(
        token="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", context=util.Interpolate("bb/%(prop:buildername)s")
    )
)

c['services'].append(
    reporters.HttpStatusPush(serverUrl="https://matrix.pramari.de/_matrix/maubot/plugin/buildbot/webhook")
)

c["buildbotNetUsageData"] = "full"

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c["title"] = "pramari.de ci/cd"
c["titleURL"] = "https://www.pramari.de"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c["buildbotURL"] = "https://build.pramari.de/"

authz = util.Authz(
    allowRules=[
        util.AnyControlEndpointMatcher(role="admins", defaultDeny=True),
        util.AnyEndpointMatcher(role="admins", defaultDeny=True),
    ],
    roleMatchers=[util.RolesFromEmails(admins=["andreas@neumeier.org"])],
)

c["www"] = dict(
    port=8010,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={},
        badges={"left_pad": 0, "right_pad": 0, "border_radius": 3, "style": "badgeio"},
    ),
    auth=PramariAuth(
        clientId=SECRET.get('clientId', None),
        clientSecret=SECRET.get('clientSecret', None),
    ),
    change_hook_dialects={
        "github": {
            "secret": SECRET.get('github', None)
        }
    },
    authz=authz,
)

####### DB URL

c["db"] = {
    # This specifies what database buildbot uses to store its state.
    # It's easy to start with sqlite, but it's recommended to switch to a dedicated
    # database, such as PostgreSQL or MySQL, for use in production environments.
    # http://docs.buildbot.net/current/manual/configuration/global.html#database-specification
    "db_url": "sqlite:///state.sqlite",
}
