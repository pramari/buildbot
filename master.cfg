# -*- python -*-
# ex: set filetype=python:


"""
master.cfg

DO NOT EDIT THIS FILE LOCALLY!
ITS UNDER VERSION CONTROL AND UPDATES FROM GIT.

See here:
    git@github.com:andreasofthings/buildbot.git

"""

import json
import requests
from buildbot.plugins import *

from buildbot.www.oauth2 import OAuth2Auth  # for custom authentication
from buildbot.secrets.providers.base import SecretProviderBase  # for custom secrets


class PramariAuth(OAuth2Auth):
    name = "Pramari"
    faIcon = "fa-python"
    resourceEndpoint = "https://www.pramari.de"
    authUri = 'https://pramari.de/o/authorize/'
    tokenUri = 'https://pramari.de/o/token/'
    authUriAdditionalParams = dict(scope=" ".join(['userinfo', ]))

    def getUserInfoFromOAuthClient(self, c):
        data = self.get(c, '/api/userinfo/')
        return dict(full_name="{}, {}".format(data['last_name'], data['first_name']),
                    username=data['username'],
                    email=data["email"],
                    # avatar_url=data["picture"]
	)

    def createSessionFromToken(self, token):
        s = requests.Session()
        s.headers = {'Authorization': 'bearer ' + token['access_token']}
        s.verify = self.sslVerify
        return s


class GoogleCloudSecretProvider(SecretProviderBase):
    """
    basic provider where each secret is stored in Vault KV secret engine
    """

    name = 'GoogleCloudSecret'
    _secret = {}

    def __init__(self, *args, **kwargs):
        from google.cloud import secretmanager

        secrets = secretmanager.SecretManagerServiceClient()
        response = secrets.access_secret_version(request={"name": kwargs['secretname']})
        self._secret = json.loads(response.payload.data.decode('UTF-8'))
        super().__init__(*args, **kwargs)

    def get(self, entry):
        value = self._secret.get(entry, None)
        if value:
            return value
        else:
            raise Exception


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### SECRETS

c['secretsProviders'] = [
	secrets.SecretInAFile(dirname="/home/andreas_neumeier_org/.ssh/"), 
	GoogleCloudSecretProvider(secretname="projects/pramari-de/secrets/dbdetail/versions/13")			
] 


####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
	# worker.Worker("localworker", "pass", properties={"os":"Debian Buster"}, keepalive_interval=300),
	worker.LocalWorker('bot1'),
    	worker.LocalWorker('bot2'),
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot version of a python hello-world project.

c['change_source'] = []
# c['change_source'].append(changes.github.GitHubPullrequestPoller('git://github.com/andreasofthings/apc.git', pollInterval=599))
# c['change_source'].append(changes.GitPoller(
#       'git://github.com/buildbot/hello-world.git',
#        workdir='gitpoller-workdir', branch='master',
#        pollInterval=300))

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

c['schedulers'] = []
daily_documentation_scheduler = schedulers.Periodic(
	name="hourly",
	builderNames=["Build Documentation"],
	periodicBuildTimer=60*60*12
)
daily_staticfile_scheduler = schedulers.Periodic(
	name="daily",
	builderNames=["Collect Staticfiles"],
	periodicBuildTimer=24*60*60
)

tests_scheduler = schedulers.SingleBranchScheduler(name="Run Tests Scheduler",
                            		 change_filter=util.ChangeFilter(branch='main'),
                                         treeStableTimer=5*60,
                                         builderNames=["Run Tests",])
deploy_scheduler = schedulers.Dependent(name="deploy",
                               upstream=tests_scheduler, # <- no quotes!
                               builderNames=["Deploy AppEngine", ])


c['schedulers'].append(daily_documentation_scheduler)
c['schedulers'].append(daily_staticfile_scheduler)
c['schedulers'].append(schedulers.SingleBranchScheduler(
                            name="Build All Scheduler",
                            change_filter=util.ChangeFilter(branch='main'),
                            treeStableTimer=None,
                            builderNames=["Quality", "Run Tests", ]))


c['schedulers'].append(tests_scheduler)
c['schedulers'].append(deploy_scheduler)

c['schedulers'].append(schedulers.ForceScheduler(
                            name="force",
                            builderNames=[
				"Deploy AppEngine",
				"Run Tests",
				"Quality",
				"Build Documentation",
				"Collect Staticfiles",
				"Deploy Website",
				"Deploy Webapp"]))



####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

fetchapc = steps.Git(repourl='git@github.com:andreasofthings/apc.git', mode='incremental')
fetchweb = steps.Git(repourl='git@github.com:andreasofthings/neumeier.org.git', mode='incremental')

webapp = 'git@github.com:andreasofthings/pramari-app.git'
webapp_repo = steps.Git(repourl=webapp, mode='incremental', sshPrivateKey=util.Secret('id_rsa.webapp'), sshKnownHosts=util.Secret('known_hosts'))

factory = util.BuildFactory()
factory.addStep(fetchapc)
factory.addStep(steps.PyFlakes(command=["pyflakes", "webapp"]))
factory.addStep(steps.PyLint(command=["pylint", "webapp"]))

test_factory = util.BuildFactory()
test_factory.addStep(fetchapc)
test_factory.addStep(steps.ShellCommand(command=['python3', '-m', 'venv', 'env']))
test_factory.addStep(steps.ShellCommand(command=["./env/bin/python3", "-m", "pip", "install", "--upgrade", "pip"]))
test_factory.addStep(steps.ShellCommand(command=["./env/bin/python3", "-m", "pip", "install", "--upgrade", "-r", "requirements.txt"]))
test_factory.addStep(steps.ShellCommand(command=["./env/bin/python3", "manage.py", "test"], env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json", "BUILDBOT": "True"}))


"""
    Set CLOUDSDK_CONFIG to some temp directory
    gcloud auth activate-service-account --key-file=...
    ... use gcloud to do your work ...
    Remove temp CLOUDSDK_CONFIG directory.
"""

deploy_factory = util.BuildFactory()
deploy_factory.addStep(fetchapc)
deploy_factory.addStep(steps.ShellCommand(command=['gcloud', 'auth', 'activate-service-account', '--key-file=pramari.json'], env={'GCLOUDSDK_CONFIG': 'tmp'}))
deploy_factory.addStep(steps.ShellCommand(command=['gcloud', 'app', 'deploy'], env={'GCLOUDSDK_CONFIG': 'tmp'}))

doc_factory = util.BuildFactory()
doc_factory.addStep(fetchapc)
doc_factory.addStep(steps.Sphinx(sphinx_sourcedir="docs/source", sphinx_builddir="docs/build"))
doc_factory.addStep(steps.ShellCommand(command=["gsutil", "-m", "cp", "-r", "docs/build/*", "gs://docs.pramari.de/"]))

static_factory = util.BuildFactory()
static_factory.addStep(fetchapc)
static_factory.addStep(steps.ShellCommand(command=['python3', '-m', 'venv', 'env']))
static_factory.addStep(steps.ShellCommand(
	command=["./env/bin/python3", "-m", "pip", "install", "--upgrade", "pip"]))
static_factory.addStep(steps.ShellCommand(
	command=["./env/bin/python3", "-m", "pip", "install", "--upgrade", "-r", "requirements.txt"]))
static_factory.addStep(steps.ShellCommand(
	command=["./env/bin/python3", "manage.py", "collectstatic", "--noinput"],
	env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json"}
))

web_factory = util.BuildFactory()
web_factory.addStep(fetchweb)
web_factory.addStep(steps.ShellCommand(command=["hugo",]))

webapp_factory = util.BuildFactory()
webapp_factory.addStep(steps.Git(repourl=webapp, mode='incremental', sshPrivateKey=util.Secret('id_rsa_webapp')))
webapp_factory.addStep(steps.ShellCommand(command=['gcloud', 'auth', 'activate-service-account', '--key-file=pramari.json'], env={'GCLOUDSDK_CONFIG': 'tmp'}))
webapp_factory.addStep(steps.ShellCommand(command=['gcloud', 'app', 'deploy'], env={'GCLOUDSDK_CONFIG': 'tmp'}))

c['builders'] = []
c['builders'].append( util.BuilderConfig(name="Deploy AppEngine", workernames=["bot1", "bot2"], factory=deploy_factory))
c['builders'].append( util.BuilderConfig(name="Run Tests", workernames=["bot1", "bot2"], factory=test_factory))
c['builders'].append( util.BuilderConfig(name="Quality", workernames=["bot1", "bot2"], factory=factory))
c['builders'].append( util.BuilderConfig(name="Build Documentation", workernames=["bot1", "bot2"], factory=doc_factory))
c['builders'].append( util.BuilderConfig(name="Collect Staticfiles", workernames=["bot1", "bot2"], factory=static_factory))
c['builders'].append( util.BuilderConfig(name="Deploy Website", workernames=["bot1", "bot2"], factory=web_factory))
c['builders'].append( util.BuilderConfig(name="Deploy Webapp", workernames=["bot1", "bot2"], factory=webapp_factory))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

context = util.Interpolate("bb/%(prop:buildername)s")
c['services'] = []
c['services'].append(reporters.GitHubStatusPush(token='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',  context=context))
c['buildbotNetUsageData'] = 'full'

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "pramari.de ci/cd"
c['titleURL'] = "https://www.pramari.de"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "https://build.pramari.de/"

authz = util.Authz(
  allowRules=[
    util.AnyControlEndpointMatcher(role="admins", defaultDeny=True),
    util.AnyEndpointMatcher(role="admins", defaultDeny=True),
  ],
  roleMatchers=[
    util.RolesFromEmails(admins=["andreas@neumeier.org"])
  ]
)

c['www'] = dict(
	port=8010,
        plugins=dict(waterfall_view={}, console_view={}, grid_view={}, badges={"left_pad": 0, "right_pad": 0, "border_radius": 3, "style": "badgeio"}),
	# auth=util.GoogleAuth("82960315302-tbj0fvm03aviuah0ps66991qhjrtopak.apps.googleusercontent.com", "eVsvW5FkUKU65JJj8ksz26fX"),
	auth=PramariAuth(
		clientId="ThF4JwVtvyG46W1NhGc5FYRCRFbte0btLkEJ8pvS",
		clientSecret="PwyIc5LYV7Cb76hoPNG51RQ2N7y81PhHtvBudzQEiRGCbBktwZDJk4XbGrV6HTdvHWzinfrOIOy4orr5Ch2DcWPriNVbcWAK0HQrDPXdD2YysNWpwNngRSucWbxRbcte"
	),
	change_hook_dialects={'github': {'secret': 'BRbNFGkfC$os9W)3mXCYer>vf2,j;w2MYfzNRRdMz{HGVa6zbaoPi6fb6Fs?EEpw'}},
	authz=authz
)

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.
    # It's easy to start with sqlite, but it's recommended to switch to a dedicated
    # database, such as PostgreSQL or MySQL, for use in production environments.
    # http://docs.buildbot.net/current/manual/configuration/global.html#database-specification
    'db_url' : "sqlite:///state.sqlite",
}
# sec = secrets.SecretInAFile(dirname="/home/andreas_neumeier_org/.ssh/")
# print(sec.get("id_rsa.webapp"))
