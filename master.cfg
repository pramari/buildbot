# -*- python -*-
# ex: set filetype=python:


"""
master.cfg

DO NOT EDIT THIS FILE LOCALLY!
ITS UNDER VERSION CONTROL AND UPDATES FROM GIT.

See here:
    git@github.com:andreasofthings/buildbot.git

"""

import json
import requests
import datetime
from buildbot.plugins import util, steps, secrets, worker, schedulers, reporters

from buildbot.www.oauth2 import OAuth2Auth  # for custom authentication
from buildbot.secrets.providers.base import SecretProviderBase  # for custom secrets


class PramariAuth(OAuth2Auth):
    """This is a customer authentication class subclassed from 'py:buildbot.www.oauth2.OAuth2Auth', that
    helps users authenticate against the awesome ''

    :param name: Name of the Authenticator, defaults to 'Pramari'
    :type name: str
    """

    name = "Pramari"
    faIcon = "fa-python"
    resourceEndpoint = "https://www.pramari.de"
    authUri = "https://pramari.de/o/authorize/"
    tokenUri = "https://pramari.de/o/token/"
    authUriAdditionalParams = dict(
        scope=" ".join(
            [
                "userinfo",
            ]
        )
    )

    def getUserInfoFromOAuthClient(self, c):
        data = self.get(c, "/api/userinfo/")
        return dict(
            full_name="{}, {}".format(data["last_name"], data["first_name"]),
            username=data["username"],
            email=data["email"],
            # avatar_url=data["picture"]
        )

    def createSessionFromToken(self, token):
        s = requests.Session()
        s.headers = {"Authorization": "bearer " + token["access_token"]}
        s.verify = self.sslVerify
        return s


class GoogleCloudSecretProvider(SecretProviderBase):
    """Basic provider where each secret is stored in Vault KV secret engine.

    Todo:
      * read secrets from google
      * make it actually work with buildbot
    """

    name = "GoogleCloudSecret"
    _secret = {}

    def __init__(self, *args, **kwargs):
        """
        kwargs:: secretname
        kwargs:: secretversion
        """
        from google.cloud import secretmanager

        secrets = secretmanager.SecretManagerServiceClient()
        response = secrets.access_secret_version(request={"name": kwargs["secretname"]})
        self._secret = json.loads(response.payload.data.decode("UTF-8"))
        super().__init__(*args, **kwargs)

    def get(self, entry):
        return self._secret.get(entry, None)


class LimitAppEngineVersions(steps.BuildStep):
    from twisted.internet import defer

    def __init__(self, serviceName=None, limit=15, **kwargs):

        if not serviceName:
            raise TypeError("servicename argument is required")

        # call parent
        super().__init__(**kwargs)

    # @defer.inlineCallbacks
    def run(self):
        from googleapiclient.discovery import build

        with build("appengine", "v1") as service:
            pass


class ReleaseDate(steps.BuildStep):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def run(self, **kwargs):
        try:
            with open("release", "w") as f:
                """
                .. todo::
                  actually update date in `release`
                """
                n = datetime.datetime.now()
                f.write(f"{n.year}-{n.month}-{n.day}-{n.hour}")
        except IOError:
            print("File not accessible")


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### SECRETS

c["secretsProviders"] = [
    secrets.SecretInAFile(dirname="/home/andreas_neumeier_org/.ssh/", strip=False),
    # GoogleCloudSecretProvider(
    #    secretname="projects/pramari-de/secrets/dbdetail/versions/latest"
    # ),
]


####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

kube_config = util.KubeCtlProxyConfigLoader()

c["workers"] = [
    # worker.Worker("localworker", "pass", properties={"os":"Debian Buster"}, keepalive_interval=300),
    worker.LocalWorker("bot1"),
    worker.KubeLatentWorker(
        "kubeworker",
        namespace="default",
        kube_config=kube_config,
        masterFQDN="10.156.15.212",
    ),
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c["protocols"] = {"pb": {"port": 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot version of a python hello-world project.

c["change_source"] = []
# c['change_source'].append(changes.github.GitHubPullrequestPoller('git://github.com/andreasofthings/apc.git', pollInterval=599))
# c['change_source'].append(changes.GitPoller(
#       'git://github.com/buildbot/hello-world.git',
#        workdir='gitpoller-workdir', branch='master',
#        pollInterval=300))


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

### Fetch Source Steps

fetchapc_ssh = steps.GitHub(
    name="Fetch Source for APC (with key)",
    repourl="git@github.com:andreasofthings/apc.git",
    branch="main",
    mode="full",
    method="clobber",
    sshPrivateKey=util.Secret("id_rsa"),
    sshHostKey=util.Secret("github.com"),
)


fetchcrmeta = steps.GitHub(
    name="Fetch crmeta Package Source",
    repourl="git@github.com:andreasofthings/crmeta.git",
    branch="main",
    mode="full",
    method="clobber",
    sshPrivateKey=util.Secret("id_rsa"),
    sshHostKey=util.Secret("github.com"),
)

### Generic venv Steps for all packages

create_venv = steps.ShellCommand(
    name="Create a Virtual Environment", command=["python3", "-m", "virtualenv", "env"]
)

update_pip = steps.ShellCommand(
    name="Update pip in Virtual Environment",
    command=[
        "./env/bin/python3",
        "-m",
        "pip",
        "install",
        "--upgrade",
        "pip",
        "pylint",
        "pyflakes",
        "mypy",
    ],
)
provide_mysql = steps.ShellCommand(
    name="Install default-libmysqlclient-dev",
    command=["su", "-c", "apt", "install", "default-libmysqlclient-dev", ],
)
prep_venv = steps.ShellCommand(
    name="Install requirements.txt",
    command=[
        "./env/bin/python3",
        "-m",
        "pip",
        "install",
        "--upgrade",
        "-r",
        "requirements.txt",
    ],
)



### BuildFactories

apc_quality_factory = util.BuildFactory()
apc_quality_factory.addStep(fetchapc_ssh)
apc_quality_factory.addStep(create_venv)
apc_quality_factory.addStep(update_pip)
apc_quality_factory.addStep(provide_mysql)
apc_quality_factory.addStep(prep_venv)
apc_quality_factory.addStep(
    steps.PyFlakes(command=["./env/bin/python3", "-m", "pyflakes", "webapp"])
)
apc_quality_factory.addStep(
    steps.PyLint(command=["./env/bin/python3", "-m", "pylint", "webapp"])
)
apc_quality_factory.addStep(
    steps.ShellCommand(
        name="MyPy",
        command=[
            "./env/bin/python3",
            "-m",
            "mypy",
            "--install-types",
            "--non-interactive",
            "--ignore-missing-imports",
            "webapp",
        ]
    )
)

apc_test_factory = util.BuildFactory()
apc_test_factory.addStep(fetchapc_ssh)
apc_test_factory.addStep(create_venv)
apc_test_factory.addStep(update_pip)
apc_test_factory.addStep(provide_mysql)
apc_test_factory.addStep(prep_venv)
apc_test_factory.addStep(
    steps.ShellCommand(
        name="Run all tests through `manage.py test`",
        command=["./env/bin/python3", "manage.py", "test"],
        env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json", "BUILDBOT": "True"},
    )
)


apc_deploy_factory = util.BuildFactory()
apc_deploy_factory.addStep(fetchapc_ssh)
apc_deploy_factory.addStep(
    steps.ShellCommand(
        command=[
            "gcloud",
            "auth",
            "activate-service-account",
            "--key-file=pramari.json",
        ],
        env={"GCLOUDSDK_CONFIG": "tmp"},
    )
)

# apc_deploy_factory.addStep(
#    ReleaseDate(name="Update Release Date")
# )

# apc_deploy_factory.addStep(
#    LimitAppEngineVersions(serviceName="default")
# )

apc_deploy_factory.addStep(
    steps.ShellCommand(
        name="Deploy to AppEngine",
        command=["gcloud", "app", "deploy"],
        env={"GCLOUDSDK_CONFIG": "tmp"},
    )
)

apc_doc_factory = util.BuildFactory()
apc_doc_factory.addStep(fetchapc_ssh)
apc_doc_factory.addStep(create_venv)
# apc_doc_factory.addStep(update_pip)
apc_doc_factory.addStep(provide_mysql)
apc_doc_factory.addStep(prep_venv)
apc_doc_factory.addStep(
    steps.ShellCommand(
        name="Build Documentation",
        command=["./env/bin/sphinx-build", "docs/source", "docs/build"],
    )
)
apc_doc_factory.addStep(
    steps.ShellCommand(
        name="Copy Documentation to gs://",
        command=["gsutil", "-m", "cp", "-r", "docs/build/*", "gs://docs.pramari.de/"],
    )
)

apc_static_factory = util.BuildFactory()
apc_static_factory.addStep(fetchapc_ssh)
apc_static_factory.addStep(create_venv)
apc_static_factory.addStep(update_pip)
apc_static_factory.addStep(provide_mysql)
apc_static_factory.addStep(prep_venv)
apc_static_factory.addStep(
    steps.ShellCommand(
        name="Collect static files",
        command=["./env/bin/python3", "manage.py", "collectstatic", "--noinput"],
        env={"GOOGLE_APPLICATION_CREDENTIALS": "pramari.json"},
    )
)


### Builders Configuration

c["builders"] = []
c["builders"].append(
    util.BuilderConfig(
        name="Deploy APC to AppEngine",
        workernames=[
            "kubeworker",
        ],
        factory=apc_deploy_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Run APC Tests",
        workernames=[
            "kubeworker",
        ],
        factory=apc_test_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Check APC Quality",
        workernames=[
            "kubeworker",
        ],
        factory=apc_quality_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Build Documentation",
        workernames=[
            "kubeworker",
        ],
        factory=apc_doc_factory,
    )
)
c["builders"].append(
    util.BuilderConfig(
        name="Collect Staticfiles",
        workernames=[
            "kubeworker",
        ],
        factory=apc_static_factory,
    )
)

### Full Pipeline for CRMeta


#### CRMeta BuildFactory

crmeta_quality_factory = util.BuildFactory()
crmeta_quality_factory.addStep(fetchcrmeta)
crmeta_quality_factory.addStep(create_venv)
crmeta_quality_factory.addStep(update_pip)
crmeta_quality_factory.addStep(
    steps.PyFlakes(command=["./env/bin/python3", "-m", "pyflakes", "crmeta"])
)
crmeta_quality_factory.addStep(
    steps.PyLint(command=["./env/bin/python3", "-m", "pylint", "crmeta"])
)
crmeta_quality_factory.addStep(
    steps.ShellCommand(command=["./env/bin/python3", "runtests.py"])
)

crmeta_behave_factory = util.BuildFactory()
crmeta_behave_factory.addStep(fetchcrmeta)
crmeta_behave_factory.addStep(create_venv)
crmeta_behave_factory.addStep(update_pip)
crmeta_behave_factory.addStep(steps.ShellCommand(command=["behave", "crmeta/features"]))

crmeta_tox_factory = util.BuildFactory()
crmeta_tox_factory.addStep(fetchcrmeta)
crmeta_tox_factory.addStep(create_venv)
crmeta_tox_factory.addStep(update_pip)
crmeta_tox_factory.addStep(steps.ShellCommand(command=["tox"]))


#### CRMeta Builders

c["builders"].append(
    util.BuilderConfig(
        name="crmeta quality",
        workernames=[
            "kubeworker",
        ],
        factory=crmeta_quality_factory,
    )
)

c["builders"].append(
    util.BuilderConfig(
        name="crmeta behave",
        workernames=[
            "kubeworker",
        ],
        factory=crmeta_behave_factory,
    )
)

c["builders"].append(
    util.BuilderConfig(
        name="crmeta tox",
        workernames=[
            "kubeworker",
        ],
        factory=crmeta_tox_factory,
    )
)

#### CRMeta Scheduler

crmeta_quality_scheduler = schedulers.SingleBranchScheduler(
    name="On Code Change Quality Gate CRMeta Package",
    change_filter=util.ChangeFilter(
        repository="https://github.com/andreasofthings/crmeta",
        branch="main",
    ),
    builderNames=["crmeta quality"],
)

crmeta_tox_scheduler = schedulers.Dependent(
    name="Tox CRMeta Package",
    upstream=crmeta_quality_scheduler,
    builderNames=["crmeta tox"],
)

crmeta_behave_scheduler = schedulers.Dependent(
    name="Behave CRMeta Package",
    upstream=crmeta_tox_scheduler,
    builderNames=["crmeta behave"],
)

crmeta_schedulers = [
    crmeta_quality_scheduler,
    crmeta_tox_scheduler,
    crmeta_behave_scheduler,
]

#### APC SCHEDULERS

apc_quality_scheduler = schedulers.SingleBranchScheduler(
    name="Quality Check Scheduler",
    change_filter=util.ChangeFilter(
      repository="https://github.com/andreasofthings/apc",
      branch="main"
      ),
    treeStableTimer=30,
    builderNames=[
        "Check APC Quality",
    ],
)
apc_tests_scheduler = schedulers.Dependent(
    name="Run Tests Scheduler",
    upstream=apc_quality_scheduler,
    builderNames=[
        "Run APC Tests",
    ],
)
apc_deploy_scheduler = schedulers.Dependent(
    name="deploy",
    upstream=apc_tests_scheduler,  # <- no quotes!
    builderNames=[
        "Deploy APC to AppEngine",
    ],
)

apc_schedulers = [
    apc_quality_scheduler,
    apc_tests_scheduler,
    apc_deploy_scheduler
]

#### Periodic

periodic_schedulers = [
    schedulers.Periodic(
        name="daily", 
        builderNames=["Build Documentation", "Collect Staticfiles"], 
        periodicBuildTimer=24 * 60 * 60
    )
]


####### SCHEDULERS

c["schedulers"] = []

c["schedulers"] += apc_schedulers
c["schedulers"] += crmeta_schedulers
c["schedulers"] += periodic_schedulers

c["schedulers"].append(                 # Force
    schedulers.ForceScheduler(
        name="force",
        builderNames=[
            "Build Documentation",      # every 24h only, otherwise
            "Collect Staticfiles",      # every 24h only, otherwise
            "Deploy APC to AppEngine",
            "Run APC Tests",
            "Check APC Quality",
            "crmeta quality",
            "crmeta tox",
            "crmeta behave",
        ],
    )
)


####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.


c["services"] = []

c["services"].append(
    reporters.GitHubStatusPush(
        token="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", context=util.Interpolate("bb/%(prop:buildername)s")
    )
)

c["buildbotNetUsageData"] = "full"

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c["title"] = "pramari.de ci/cd"
c["titleURL"] = "https://www.pramari.de"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c["buildbotURL"] = "https://build.pramari.de/"

authz = util.Authz(
    allowRules=[
        util.AnyControlEndpointMatcher(role="admins", defaultDeny=True),
        util.AnyEndpointMatcher(role="admins", defaultDeny=True),
    ],
    roleMatchers=[util.RolesFromEmails(admins=["andreas@neumeier.org"])],
)

c["www"] = dict(
    port=8010,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={},
        badges={"left_pad": 0, "right_pad": 0, "border_radius": 3, "style": "badgeio"},
    ),
    # auth=util.GoogleAuth("82960315302-tbj0fvm03aviuah0ps66991qhjrtopak.apps.googleusercontent.com", "eVsvW5FkUKU65JJj8ksz26fX"),
    auth=PramariAuth(
        clientId="ThF4JwVtvyG46W1NhGc5FYRCRFbte0btLkEJ8pvS",
        clientSecret="PwyIc5LYV7Cb76hoPNG51RQ2N7y81PhHtvBudzQEiRGCbBktwZDJk4XbGrV6HTdvHWzinfrOIOy4orr5Ch2DcWPriNVbcWAK0HQrDPXdD2YysNWpwNngRSucWbxRbcte",
    ),
    change_hook_dialects={
        "github": {
            "secret": "BRbNFGkfC$os9W)3mXCYer>vf2,j;w2MYfzNRRdMz{HGVa6zbaoPi6fb6Fs?EEpw"
        }
    },
    authz=authz,
)

####### DB URL

c["db"] = {
    # This specifies what database buildbot uses to store its state.
    # It's easy to start with sqlite, but it's recommended to switch to a dedicated
    # database, such as PostgreSQL or MySQL, for use in production environments.
    # http://docs.buildbot.net/current/manual/configuration/global.html#database-specification
    "db_url": "sqlite:///state.sqlite",
    # "db_url": "mysql://buildbot:;xCt?o2^u[2ZZ_qd@35.246.128.159/build-pramari-de?max_idle=300",
}
